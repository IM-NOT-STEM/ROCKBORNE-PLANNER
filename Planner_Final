# app_main.py
from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv(), override=True)

import os, re, io, time, urllib.parse, unicodedata, requests, pandas as pd, html, json
import gradio as gr
from bs4 import BeautifulSoup
import plotly.graph_objects as go

# ================== Config ==================
DEFAULT_DEST = "Cancún, Mexico"
CATEGORIES = ["nightclubs","bars","restaurants","live music","beach clubs","cafes"]
UNITS = ["METRIC","IMPERIAL"]
MAP_MODES = ["Grid (per category)", "Single Google Map (combined)"]
INSIDE_AIRBNB_INDEX = "https://insideairbnb.com/get-the-data/"
UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36"
HDR = {"User-Agent": UA, "Accept-Language": "en"}
PLACES_KEY = os.getenv("GOOGLE_MAPS_API_KEY", "")

# Default currency per country (covers common travel spots)
CURRENCY_BY_COUNTRY = {
    # Americas
    "US": "USD", "CA": "CAD", "MX": "MXN", "CR": "CRC", "PA": "PAB", "DO": "DOP",
    "CO": "COP", "AR": "ARS", "CL": "CLP", "PE": "PEN", "UY": "UYU", "BR": "BRL",
    # Europe
    "GB": "GBP", "IE": "EUR", "ES": "EUR", "PT": "EUR", "FR": "EUR", "DE": "EUR",
    "IT": "EUR", "GR": "EUR", "NL": "EUR", "BE": "EUR", "AT": "EUR", "CZ": "CZK",
    "PL": "PLN", "HU": "HUF", "CH": "CHF", "TR": "TRY",
    # Africa & Middle East
    "ZA": "ZAR", "MA": "MAD", "EG": "EGP", "AE": "AED", "TZ": "TZS", "KE": "KES",
    # Asia-Pacific
    "TH": "THB", "VN": "VND", "MY": "MYR", "SG": "SGD", "ID": "IDR", "PH": "PHP",
    "JP": "JPY", "KR": "KRW", "TW": "TWD", "HK": "HKD", "AU": "AUD", "NZ": "NZD",
    "IN": "INR", "LK": "LKR", "NP": "NPR", "KH": "KHR", "LA": "LAK",
}

# Colors for categories on the combined map
CAT_COLOR = {
    "nightclubs": "#a855f7",  # purple
    "bars": "#ef4444",        # red
    "restaurants": "#3b82f6", # blue
    "cafes": "#22c55e",       # green
    "live music": "#f59e0b",  # amber
    "beach clubs": "#06b6d4", # cyan
}

# Map categories to Places API params
CATEGORY_TO_PLACES = {
    "bars":         {"type": "bar",          "keyword": None},
    "nightclubs":   {"type": "night_club",   "keyword": None},
    "restaurants":  {"type": "restaurant",   "keyword": None},
    "cafes":        {"type": "cafe",         "keyword": None},
    "live music":   {"type": "bar",          "keyword": "live music"},
    "beach clubs":  {"type": "bar",          "keyword": "beach club"},
}

# ================== Google Maps Embed (grid mode) ==================
def build_embed_url(destination: str, category: str, zoom: int = 13, maptype: str = "roadmap") -> str:
    api_key = os.getenv("GOOGLE_MAPS_API_KEY", "")
    if not api_key: return ""
    q = f"{category} near {destination}".strip()
    q_enc = urllib.parse.quote(q)
    return f"https://www.google.com/maps/embed/v1/search?key={api_key}&q={q_enc}&zoom={zoom}&maptype={maptype}"

def make_iframe_grid(destination: str, categories: list[str], zoom: int, maptype: str, height: int) -> str:
    api_key = os.getenv("GOOGLE_MAPS_API_KEY", "")
    if not api_key:
        return "<div style='color:red;padding:1rem'>Error: Missing GOOGLE_MAPS_API_KEY environment variable.</div>"
    cats = [c for c in (categories or []) if c in CATEGORIES] or ["nightclubs","bars"]
    cards = []
    for cat in cats:
        q = f"{cat} near {destination}".strip()
        q_enc = urllib.parse.quote(q)
        url = f"https://www.google.com/maps/embed/v1/search?key={api_key}&q={q_enc}&zoom={zoom}&maptype={maptype}"
        cards.append(f"""
        <div class="card">
          <div class="card-title">{cat.title()}</div>
          <iframe width="100%" height="{height}" frameborder="0" style="border:0"
            referrerpolicy="no-referrer-when-downgrade" allowfullscreen src="{url}"></iframe>
        </div>""")
    return f"""
    <style>
      .grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
               gap: 12px; align-items: start; }}
      .card {{ background:#fff; border:1px solid #e5e7eb; border-radius: 12px; overflow: hidden; }}
      .card-title {{ font:600 14px/1.2 system-ui, sans-serif; padding: 8px 10px; background:#f8fafc; border-bottom:1px solid #e5e7eb; }}
    </style>
    <div class="grid">
      {''.join(cards)}
    </div>
    """

# ================== Geocode (OSM Nominatim) ==================
def geocode_destination(dest: str):
    r = requests.get(
        "https://nominatim.openstreetmap.org/search",
        params={"q": dest, "format": "json", "limit": 1, "addressdetails": 1},
        headers={"User-Agent": "holiday-planner/1.0"},
        timeout=15,
    )
    r.raise_for_status()
    arr = r.json()
    if not arr: return None
    x = arr[0]; addr = x.get("address", {})
    return {
        "lat": float(x["lat"]), "lon": float(x["lon"]),
        "display_name": x.get("display_name", dest),
        "country": addr.get("country",""), "country_code": (addr.get("country_code") or "").upper(),
        "city_like": addr.get("city") or addr.get("town") or addr.get("village") or dest
    }

# ================== Google Weather API ==================
def _gw_key():
    k = os.getenv("GOOGLE_MAPS_API_KEY", "")
    if not k: raise RuntimeError("GOOGLE_MAPS_API_KEY not set")
    return k

def google_weather_current(lat: float, lon: float, units_system="METRIC"):
    url = "https://weather.googleapis.com/v1/currentConditions:lookup"
    r = requests.get(url, params={
        "key": _gw_key(),
        "location.latitude": lat,
        "location.longitude": lon,
        "unitsSystem": units_system,
    }, timeout=15)
    r.raise_for_status()
    j = r.json()
    wind = (j.get("wind") or {})
    speed = (wind.get("speed") or {}).get("value")
    gust  = (wind.get("gust") or {}).get("value")
    out = {
        "temp": (j.get("temperature") or {}).get("degrees"),
        "feels_like": (j.get("feelsLikeTemperature") or {}).get("degrees"),
        "humidity": j.get("relativeHumidity"),
        "cloud_cover": j.get("cloudCover"),
        "condition": ((j.get("weatherCondition") or {}).get("description") or {}).get("text"),
        "wind_kmh": speed if units_system=="METRIC" else None,
        "wind_mph": speed if units_system=="IMPERIAL" else None,
        "gust_kmh": gust if units_system=="METRIC" else None,
        "gust_mph": gust if units_system=="IMPERIAL" else None,
        "pressure_mbar": (j.get("airPressure") or {}).get("meanSeaLevelMillibars"),
        "uv_index": j.get("uvIndex"),
        "precip_prob": ((j.get("precipitation") or {}).get("probability") or {}).get("percent"),
    }
    return out

def google_weather_daily(lat: float, lon: float, days=5, units_system="METRIC"):
    url = "https://weather.googleapis.com/v1/forecast/days:lookup"
    r = requests.get(url, params={
        "key": _gw_key(),
        "location.latitude": lat,
        "location.longitude": lon,
        "days": max(1, min(days, 10)),
        "unitsSystem": units_system,
    }, timeout=15)
    r.raise_for_status()
    j = r.json()
    out = []
    for d in j.get("forecastDays", []):
        dd = d.get("displayDate") or {}
        w  = ((d.get("daytimeForecast") or {}).get("wind") or {}).get("speed") or {}
        out.append({
            "date": f"{dd.get('year','')}-{str(dd.get('month','')).zfill(2)}-{str(dd.get('day','')).zfill(2)}",
            "tmax": (d.get("maxTemperature") or {}).get("degrees"),
            "tmin": (d.get("minTemperature") or {}).get("degrees"),
            "wind": w.get("value"),
            "humidity_day": (d.get("daytimeForecast") or {}).get("relativeHumidity"),
            "cloud_day": (d.get("daytimeForecast") or {}).get("cloudCover"),
        })
    return out

# ================== InsideAirbnb helpers (currency inference) ==================
def _ascii(s: str) -> str:
    return unicodedata.normalize("NFKD", s).encode("ascii","ignore").decode("ascii").lower()

def _closest_city_section(soup: BeautifulSoup, want_city: str, want_country: str):
    want_city_l = _ascii(want_city)
    want_country_l = _ascii(want_country or "")
    best = None; best_score = -1
    for h3 in soup.select("h3"):
        name = h3.get_text(" ", strip=True)
        name_l = _ascii(name)
        score = 0
        if want_city_l and want_city_l in name_l: score += 3
        if want_country_l and want_country_l in name_l: score += 2
        overlap = len(set(want_city_l.split()) & set(name_l.split()))
        score += overlap
        if score > best_score:
            best, best_score = h3, score
    return best

def _find_listings_gz_after(h3: BeautifulSoup) -> str | None:
    cur = h3
    for _ in range(60):
        cur = cur.find_next_sibling()
        if not cur: break
        if cur.name == "h3": break
        a = cur.find("a", href=True) if hasattr(cur, "find") else None
        if a and a.get("href","").endswith("listings.csv.gz"):
            return a["href"]
    return None

def _detect_currency_from_text(series_str: pd.Series) -> tuple[str|None, str|None]:
    sample = " ".join(series_str.head(200).astype(str).tolist())
    if "R$" in sample: return "BRL", "symbol R$"
    if "S/" in sample or "S/." in sample: return "PEN", "symbol S/"
    if "€" in sample: return "EUR", "symbol €"
    if "£" in sample: return "GBP", "symbol £"
    if "฿" in sample: return "THB", "symbol ฿"
    if "₱" in sample: return "PHP", "symbol ₱"
    if "₡" in sample: return "CRC", "symbol ₡"
    if "₫" in sample: return "VND", "symbol ₫"
    if "$" in sample:  return "USD", "symbol $ (ambiguous)"
    return None, None

def _clean_price_series(series_str: pd.Series) -> pd.Series:
    s = series_str.dropna().astype(str)
    s = s.str.replace(",", "", regex=False)
    s = s.str.replace(r"[^\d\.]", "", regex=True)
    return pd.to_numeric(s, errors="coerce").dropna()

def scrape_airbnb_stats_gbp(dest: str):
    """
    Improved: prefers price_usd; otherwise infers currency from explicit columns,
    symbols, or country mapping; converts to GBP via frankfurter.app.
    """
    geo = geocode_destination(dest)
    if not geo:
        return {"error": f"Couldn't geocode {dest}"}

    idx = requests.get(INSIDE_AIRBNB_INDEX, headers=HDR, timeout=20)
    idx.raise_for_status()
    soup = BeautifulSoup(idx.text, "lxml")

    h3 = _closest_city_section(soup, geo["city_like"], geo["country"])
    if not h3:
        return {"error": f"No matching city on Inside Airbnb for {geo['city_like']}, {geo['country']}"}

    url = _find_listings_gz_after(h3)
    if not url:
        return {"error": "City found on Inside Airbnb, but no listings.csv.gz link in section."}

    csv_resp = requests.get(url, headers=HDR, timeout=60)
    csv_resp.raise_for_status()
    df = pd.read_csv(io.BytesIO(csv_resp.content), compression="gzip", low_memory=False)

    # choose price column (prefer price_usd if present)
    if "price_usd" in df.columns:
        vals = pd.to_numeric(df["price_usd"], errors="coerce").dropna()
        if vals.empty:
            return {"error": "price_usd column is empty.", "source_url": url}
        currency_code, currency_source = "USD", "price_usd column"
    else:
        price_col = None
        for cand in ["price", "Price", "PRICE"]:
            if cand in df.columns:
                price_col = cand; break
        if not price_col:
            return {"error": "No suitable price column (price / price_usd) found.", "source_url": url}

        # explicit currency columns?
        currency_code = None; currency_source = None
        for col in ["currency", "host_currency", "native_currency"]:
            if col in df.columns and df[col].notna().any():
                mode_val = str(df[col].dropna().astype(str).mode().iloc[0]).upper()
                if 2 <= len(mode_val) <= 3:
                    currency_code, currency_source = mode_val, f"{col} column"
                    break

        # symbols in text?
        if not currency_code:
            sraw = df[price_col].dropna().astype(str)
            sym_code, sym_src = _detect_currency_from_text(sraw)
            if sym_code:
                currency_code, currency_source = sym_code, sym_src

        # ambiguous $ → prefer country mapping
        if (not currency_code) or (currency_code == "USD" and currency_source and "$" in currency_source):
            cc = (geo.get("country_code") or "").upper()
            mapped = CURRENCY_BY_COUNTRY.get(cc)
            if mapped:
                currency_code = mapped
                currency_source = f"country mapping ({cc}→{mapped})"

        if not currency_code:
            return {"error": "Could not infer currency for 'price' column.", "source_url": url}

        vals = _clean_price_series(df[price_col])
        if vals.empty:
            return {"error": "All 'price' values were empty after cleaning.", "source_url": url}

    # convert to GBP
    if currency_code == "GBP":
        gbp_series = vals.astype(float)
        fx_note = "no conversion"
    else:
        try:
            r = requests.get("https://api.frankfurter.app/latest",
                             params={"from": currency_code, "to": "GBP"}, timeout=10)
            r.raise_for_status()
            rate = (r.json().get("rates") or {}).get("GBP")
            if not rate:
                return {"error": f"FX rate not available for {currency_code}→GBP.", "source_url": url}
            gbp_series = (vals.astype(float) * float(rate)).round(2)
            fx_note = f"rate {currency_code}→GBP = {rate}"
        except Exception as e:
            return {"error": f"FX lookup failed: {e}", "source_url": url}

    if gbp_series.empty:
        return {"error": "Converted GBP series is empty.", "source_url": url}

    lo, hi = gbp_series.quantile(0.05), gbp_series.quantile(0.95)
    gbp_clipped = gbp_series[(gbp_series >= lo) & (gbp_series <= hi)]

    return {
        "count": int(len(gbp_series)),
        "mean_gbp": round(float(gbp_series.mean()), 2),
        "median_gbp": round(float(gbp_series.median()), 2),
        "p05_gbp": round(float(lo), 2),
        "p95_gbp": round(float(hi), 2),
        "matched_city": h3.get_text(" ", strip=True),
        "source_url": url,
        "currency": "GBP",
        "src_currency_code": currency_code,
        "currency_source": currency_source,
        "fx_note": fx_note,
        "note": "Source: Inside Airbnb (CC BY 4.0). FX by frankfurter.app",
        "hist_values": gbp_clipped.tolist(),
    }

def make_histogram(values_gbp: list[float]) -> go.Figure:
    fig = go.Figure()
    fig.add_trace(go.Histogram(
        x=values_gbp, nbinsx=40, marker_color="#6366f1", opacity=0.85, name="Nightly price (GBP)"
    ))
    fig.update_layout(
        template="plotly_white", title="Nightly Airbnb price distribution (GBP, 5–95% trimmed)",
        xaxis_title="£ per night", yaxis_title="Listings", height=360, bargap=0.05,
    )
    return fig

# ================== Google Places Nearby (server-side data + quality) ==================
def _places_nearby_page(lat: float, lon: float, type_name: str, radius: int, keyword: str | None = None, pagetoken: str | None = None):
    base = "https://maps.googleapis.com/maps/api/place/nearbysearch/json"
    params = {"key": PLACES_KEY, "location": f"{lat},{lon}", "radius": radius, "type": type_name}
    if keyword: params["keyword"] = keyword
    if pagetoken: params["pagetoken"] = pagetoken
    r = requests.get(base, params=params, timeout=15)
    r.raise_for_status()
    return r.json()

def places_nearby_categories(lat: float, lon: float, categories: list[str], radius: int = 2000):
    if not PLACES_KEY:
        raise RuntimeError("GOOGLE_MAPS_API_KEY missing or Places API not enabled.")
    cat_defs = [CATEGORY_TO_PLACES[c] for c in categories if c in CATEGORY_TO_PLACES]
    venues = []; counts = {c: 0 for c in categories}
    for cat, cd in zip(categories, cat_defs):
        token = None; pages = 0
        while pages < 3:
            data = _places_nearby_page(lat, lon, cd["type"], radius, cd["keyword"], token)
            results = data.get("results", [])
            for p in results:
                venues.append({
                    "category": cat, "type": cd["type"], "name": p.get("name"),
                    "lat": p["geometry"]["location"]["lat"], "lon": p["geometry"]["location"]["lng"],
                    "rating": p.get("rating"), "user_ratings_total": p.get("user_ratings_total", 0),
                    "price_level": p.get("price_level"), "place_id": p.get("place_id"),
                })
            counts[cat] += len(results)
            token = data.get("next_page_token")
            if not token: break
            pages += 1
            time.sleep(2)  # required delay
    return counts, venues

def _price_symbol(level: int | None) -> str:
    if level is None: return "—"
    return "£" * max(1, min(int(level)+1, 4))  # 0→£, 1→££, 2→£££, 3→££££

def nightlife_quality(venues: list[dict]) -> dict:
    if not venues:
        return {"quality_score": 0, "avg_rating": None, "total": 0, "top": []}
    type_w = {"nightclubs": 1.3, "bars": 1.1, "restaurants": 0.7, "cafes": 0.6, "live music": 1.15, "beach clubs": 1.15}
    scores, ratings = [], []
    for v in venues:
        r = v.get("rating"); n = v.get("user_ratings_total", 0) or 0
        if r is None: continue
        ratings.append(r)
        rev_w = min(1.0, (n / 200.0) ** 0.5)
        cat_w = type_w.get(v.get("category"), 1.0)
        base = max(0.0, r - 3.5)
        scores.append(base * (0.7 + 0.3*rev_w) * cat_w)
    quality = round(sum(scores), 2) if scores else 0.0
    avg_rating = round(sum(ratings)/len(ratings), 2) if ratings else None
    def venue_key(v):
        r = v.get("rating") or 0
        n = max(0, v.get("user_ratings_total", 0))
        return r * (1 + (n/100.0) ** 0.5)
    top_raw = sorted([v for v in venues if v.get("rating")], key=venue_key, reverse=True)[:10]
    top_list = []
    for v in top_raw:
        link = f"https://www.google.com/maps/place/?q=place_id:{v.get('place_id')}" if v.get("place_id") else None
        top_list.append({"name": v["name"], "category": v["category"], "rating": v.get("rating"),
                         "reviews": v.get("user_ratings_total", 0), "price": _price_symbol(v.get("price_level")), "link": link})
    return {"quality_score": quality, "avg_rating": avg_rating, "total": len(venues), "top": top_list}

# ================== Single Google Map (combined) — JS in iframe ==================
def make_google_combined_map(dest_name: str, center_lat: float, center_lon: float,
                             categories: list[str], radius_m: int = 2000,
                             height: int = 520, max_per_cat: int = 40) -> str:
    import json as _json, html as _html
    api_key = os.getenv("GOOGLE_MAPS_API_KEY", "")
    if not api_key:
        return "<div style='color:red;padding:1rem'>Error: Missing GOOGLE_MAPS_API_KEY environment variable.</div>"

    cats = [c for c in (categories or []) if c in CATEGORIES] or ["nightclubs", "bars"]
    cat_defs = {c: CATEGORY_TO_PLACES[c] for c in cats}
    cat_colors = {c: CAT_COLOR.get(c, "#666") for c in cats}

    doc = """
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Combined Google Map — __DEST_NAME__</title>
  <style>
    html, body, #map { height: __HEIGHT__px; margin:0; }
    .legend {
      position:absolute; right:10px; top:10px;
      background:#fff; border:1px solid #e5e7eb; border-radius:8px;
      padding:8px 10px; font:12px system-ui; box-shadow:0 1px 3px rgba(0,0,0,0.08);
      max-width: 220px;
    }
    .legend-title { font-weight:600; margin-bottom:6px; }
    .legend-row { display:flex; align-items:center; gap:6px; margin:3px 0; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="legend" id="legend"><div class="legend-title">Categories</div></div>

  <script>
    const CENTER = __CENTER_JSON__;
    const CATEGORIES = __CATS_JSON__;
    const CAT_DEFS = __CAT_DEFS_JSON__;
    const CAT_COLORS = __CAT_COLORS_JSON__;
    const RADIUS_M = __RADIUS__;
    const MAX_PER_CAT = __MAX_PER_CAT__;

    function iconFor(category) {
      const color = CAT_COLORS[category] || '#666';
      return {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor: color, fillOpacity: 1,
        strokeColor: 'white', strokeWeight: 1,
        scale: 6
      };
    }

    function initMap() {
      const map = new google.maps.Map(document.getElementById('map'), {
        center: CENTER, zoom: 13
      });
      const info = new google.maps.InfoWindow();

      // Legend
      const legend = document.getElementById('legend');
      CATEGORIES.forEach(cat => {
        const row = document.createElement('div');
        row.className = 'legend-row';
        row.innerHTML = '<span class="dot" style="background:' + CAT_COLORS[cat] + '"></span> '
                      + '<span>' + (cat[0].toUpperCase() + cat.slice(1)) + '</span>';
        legend.appendChild(row);
      });
      map.controls[google.maps.ControlPosition.RIGHT_TOP].push(legend);

      const service = new google.maps.places.PlacesService(map);
      const seenIds = new Set(); // global dedupe across categories

      function addPlaceMarker(cat, place) {
        if (!place.geometry || !place.geometry.location) return;
        const id = place.place_id || (place.name + '|' + (place.vicinity || ''));
        if (seenIds.has(id)) return; // cross-category dedupe
        seenIds.add(id);

        const m = new google.maps.Marker({
          position: place.geometry.location,
          map, icon: iconFor(cat), title: place.name
        });
        const rating = (place.rating ?? '—');
        const reviews = (place.user_ratings_total ?? 0);
        const priceLevel = (place.price_level ?? null);
        const priceStr = (priceLevel == null) ? '—' : '£'.repeat(Math.min(4, priceLevel+1));
        const link = place.place_id ? ('https://www.google.com/maps/place/?q=place_id:' + place.place_id) : null;

        m.addListener('click', () => {
          info.setContent(
            '<div><b>' + place.name + '</b><br/>'
            + cat + ' • Rating: ' + rating + ' (' + reviews + ' reviews) • Price: ' + priceStr + '<br/>'
            + (link ? ('<a href="' + link + '" target="_blank">Open in Google Maps</a>') : '')
            + '</div>'
          );
          info.open({ anchor: m, map });
        });
      }

      function runCategory(cat) {
        const def = CAT_DEFS[cat] || {};
        let pageCount = 0;
        let collected = [];
        function handle(results, status, pagination) {
          if (status === google.maps.places.PlacesServiceStatus.OK && results) {
            collected = collected.concat(results);
            if (pagination && pagination.hasNextPage && pageCount < 2) {
              pageCount++;
              setTimeout(() => pagination.nextPage(), 1200);
              return;
            }
          }
          // rank & cap
          collected.sort((a,b) => {
            const rA = (a.rating || 0) * (1 + Math.sqrt((a.user_ratings_total || 0)/100));
            const rB = (b.rating || 0) * (1 + Math.sqrt((b.user_ratings_total || 0)/100));
            return rB - rA;
          });
          collected.slice(0, MAX_PER_CAT).forEach(p => addPlaceMarker(cat, p));
        }
        service.nearbySearch({
          location: CENTER, radius: RADIUS_M,
          type: def.type || undefined,
          keyword: def.keyword || undefined
        }, handle);
      }

      CATEGORIES.forEach(runCategory);
    }
  </script>

  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=__API_KEY__&libraries=places&v=weekly&callback=initMap">
  </script>
</body>
</html>
    """

    # Fill placeholders
    doc = doc.replace("__DEST_NAME__", _html.escape(dest_name))
    doc = doc.replace("__HEIGHT__", str(int(height)))
    center_json = _json.dumps({"lat": float(center_lat), "lng": float(center_lon)})
    doc = doc.replace("__CENTER_JSON__", center_json)
    doc = doc.replace("__CATS_JSON__", _json.dumps(cats))
    doc = doc.replace("__CAT_DEFS_JSON__", _json.dumps(cat_defs))
    doc = doc.replace("__CAT_COLORS_JSON__", _json.dumps(cat_colors))
    doc = doc.replace("__RADIUS__", str(int(radius_m)))
    doc = doc.replace("__MAX_PER_CAT__", str(int(max_per_cat)))
    doc = doc.replace("__API_KEY__", _html.escape(api_key, quote=True))

    # Return as an iframe so scripts execute inside Gradio
    return f'<iframe srcdoc="{_html.escape(doc, quote=True)}" style="width:100%;height:{int(height)}px;border:0;" loading="lazy"></iframe>'

# ================== UI orchestration (logic) ==================
def generate_panels(dest, categories, map_mode, zoom, maptype, iframe_height, units_system, days, include_airbnb, places_radius, max_per_cat):
    sel_cats = [c for c in categories if c in CATEGORIES] or ["nightclubs","bars"]

    # Geocode
    geo = geocode_destination(dest or DEFAULT_DEST)
    if not geo:
        return "<div>Geocoding failed.</div>", "### Weather\n❌ Couldn't geocode destination.", go.Figure(), "### 🍸 Nightlife\n❌ Geocoding failed."

    # Server-side Places data (for counts + quality stats)
    counts, venues_all = places_nearby_categories(geo["lat"], geo["lon"], sel_cats, radius=int(places_radius))

    # Map HTML (Grid embed OR Single Google Map combined)
    if map_mode.startswith("Grid"):
        map_html = make_iframe_grid(dest or DEFAULT_DEST, sel_cats, zoom, maptype, iframe_height)
    else:
        map_html = make_google_combined_map(
            geo["display_name"], geo["lat"], geo["lon"],
            sel_cats, radius_m=int(places_radius),
            height=int(iframe_height), max_per_cat=int(max_per_cat)
        )

    # Weather
    try:
        cur = google_weather_current(geo["lat"], geo["lon"], units_system)
        dly = google_weather_daily(geo["lat"], geo["lon"], days, units_system)
        unit_line = "km/h" if units_system=="METRIC" else "mph"
        lines = [
            f"### 🌤️ Weather — **{geo['display_name']}**",
            f"- **Coords:** {geo['lat']:.4f}, {geo['lon']:.4f}  |  **Country:** {geo.get('country','—')}",
            f"- **Now:** {cur.get('temp','—')}° ({units_system}) • {cur.get('condition','—')}",
            f"- **Feels like:** {cur.get('feels_like','—')}° • **Humidity:** {cur.get('humidity','—')}% • **Clouds:** {cur.get('cloud_cover','—')}%",
            f"- **Wind:** {(cur.get('wind_kmh') if units_system=='METRIC' else cur.get('wind_mph'))} {unit_line} "
            f"(gusts {(cur.get('gust_kmh') if units_system=='METRIC' else cur.get('gust_mph'))} {unit_line})",
        ]
        if cur.get("pressure_mbar") is not None: lines.append(f"- **Pressure:** {cur['pressure_mbar']} mbar")
        if cur.get("uv_index") is not None: lines.append(f"- **UV index:** {cur['uv_index']}")
        if cur.get("precip_prob") is not None: lines.append(f"- **Precip chance:** {cur['precip_prob']}%")
        if dly:
            lines.append("\n**Next days (max/min, wind):**")
            for d in dly:
                w = d.get("wind","—")
                lines.append(f"- {d['date']}: {d.get('tmax','—')}° / {d.get('tmin','—')}° • wind {w} {unit_line}")
        lines.append("\n<sub>Weather source: Google Maps Platform Weather API.</sub>")
        weather_md = "\n".join(lines)
    except Exception as e:
        weather_md = f"### Weather\n❌ {e}"

    # Airbnb (GBP + histogram) — shows currency details
    hist = go.Figure()
    airbnb_md = ""
    if include_airbnb:
        try:
            ab = scrape_airbnb_stats_gbp(dest or DEFAULT_DEST)
            if "error" in ab:
                airbnb_md = f"### 🏠 Airbnb\n❌ {ab['error']}"
                if ab.get("source_url"):
                    airbnb_md += f"\n\n<sub>Dataset: {ab['source_url']}</sub>"
            else:
                airbnb_md = (
                    "### 🏠 Airbnb (scraped)\n"
                    f"- **Matched city:** {ab['matched_city']}\n"
                    f"- **Listings counted:** {ab['count']}\n"
                    f"- **Average nightly (mean):** £{ab['mean_gbp']}\n"
                    f"- **Median nightly:** £{ab['median_gbp']}\n"
                    f"- **5th–95th percentile:** £{ab['p05_gbp']} – £{ab['p95_gbp']}\n"
                    f"- **Currency used:** {ab.get('src_currency_code','?')} → GBP ({ab.get('currency_source','?')}; {ab.get('fx_note','')})\n"
                    f"<sub>{ab['note']}. Dataset: {ab['source_url']}</sub>"
                )
                hist = make_histogram(ab["hist_values"])
        except Exception as e:
            airbnb_md = f"### 🏠 Airbnb\n❌ Error scraping Inside Airbnb: {e}"

    # Nightlife quality
    try:
        quality = nightlife_quality(venues_all)
        counts_line = ", ".join([f"{c}: **{counts.get(c,0)}**" for c in sel_cats])
        nightlife_lines = [
            "### 🍸 Nightlife Quality",
            f"- **Categories:** {', '.join(sel_cats)}  |  **Radius:** {int(places_radius)} m",
            f"- **Total venues found:** {quality['total']}  |  **Avg rating:** {quality['avg_rating']}  |  **Quality score:** {quality['quality_score']}",
            f"- **Counts:** {counts_line}",
            "\n**Top places (rating • reviews • price):**"
        ]
        for v in quality["top"][:8]:
            name = v["name"].replace("|"," ")
            price = v["price"]
            link = v.get("link") or "#"
            nightlife_lines.append(f"- [{name}]({link}) — {v['rating']}★ • {v['reviews']} reviews • {price} • {v['category']}")
        nightlife_lines.append("\n<sub>Source: Google Places Nearby Search (ratings & price levels).</sub>")
        nightlife_md = "\n".join(nightlife_lines)
    except Exception as e:
        nightlife_md = f"### 🍸 Nightlife Quality\n❌ {e}\n\n<sub>Ensure Places API is enabled and the same key is used.</sub>"

    combined_md = weather_md + ("\n\n" + airbnb_md if airbnb_md else "")
    return map_html, combined_md, hist, nightlife_md

# ================== Theme, CSS, Presets, Helpers ==================
custom_theme = gr.themes.Soft(
    primary_hue="indigo",
    secondary_hue="cyan",
    neutral_hue="slate"
)

APP_CSS = """
#app-header{background:linear-gradient(135deg,#0ea5e9,#6366f1);color:#fff;
padding:18px 20px;border-radius:14px;margin-bottom:10px}
#app-header h1{font:700 22px/1.2 system-ui,Segoe UI,Roboto,Helvetica,Arial}
#app-header p{opacity:.95;margin:.35rem 0 0}
.badge{display:inline-flex;align-items:center;gap:6px;background:#0b1220;
color:#cbd5e1;border:1px solid #334155;border-radius:999px;padding:4px 10px;
font:600 12px/1 system-ui;margin-right:6px;white-space:nowrap}
.card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:12px}
.footer-note{color:#64748b;font-size:12px;margin-top:10px}
"""

PRESETS = [
    "Cancún, Mexico",
    "Phuket, Thailand",
    "Bali, Indonesia",
    "Cartagena, Colombia",
    "Goa, India",
]

def _set_dest(preset): return preset or ""
def _select_all(): return ["nightclubs","bars","restaurants","live music","beach clubs","cafes"]
def _select_core(): return ["nightclubs","bars"]
def _clear_inputs():
    return "Cancún, Mexico", _select_core(), "Single Google Map (combined)", 520, True, 2000, 40, "METRIC", 5

# ================== Gradio UI (refreshed) ==================
with gr.Blocks(
    title="Holiday Planner • One Google Map + Weather + Airbnb (GBP) + Nightlife Quality",
    theme=custom_theme,
    css=APP_CSS
) as demo:

    # Header
    gmaps_ok = bool(os.getenv("GOOGLE_MAPS_API_KEY"))
    gr.HTML(
        f"""
        <div id="app-header">
          <h1>🏝️ Tropical Holiday Planner</h1>
          <p>Find warm destinations with great nightlife. Compare weather, bars/clubs, and typical Airbnb prices.</p>
          <div style="margin-top:8px">
            <span class="badge">{'✅' if gmaps_ok else '❌'} Google APIs</span>
            <span class="badge">🌤️ Weather</span>
            <span class="badge">🍹 Nightlife</span>
            <span class="badge">🏠 Airbnb scrape</span>
          </div>
        </div>
        """
    )

    with gr.Row():
        # ---------- Left control panel ----------
        with gr.Column(scale=1, min_width=320):
            with gr.Tab("Search"):
                dest = gr.Textbox(
                    label="Destination",
                    value=DEFAULT_DEST,
                    placeholder="e.g., Phuket, Thailand",
                    info="City, island, or well-known beach area"
                )
                preset = gr.Radio(PRESETS, label="Quick presets (optional)", value=None)
                preset.change(_set_dest, inputs=preset, outputs=dest)

                categories = gr.CheckboxGroup(
                    CATEGORIES,
                    value=["nightclubs","bars"],
                    label="Categories",
                    info="Pick one or more"
                )

                with gr.Row():
                    btn_all = gr.Button("Select all", size="sm")
                    btn_core = gr.Button("Bars & Clubs", size="sm")
                btn_all.click(_select_all, inputs=None, outputs=categories)
                btn_core.click(_select_core, inputs=None, outputs=categories)

                map_mode = gr.Dropdown(
                    MAP_MODES,
                    value="Single Google Map (combined)",
                    label="Map mode",
                    info="Show one combined map or separate embeds per category"
                )

                run_btn = gr.Button("🔎 Find nightlife & prices", variant="primary")

            with gr.Tab("Advanced"):
                with gr.Accordion("Map options", open=False):
                    zoom = gr.Slider(3, 20, value=13, step=1, label="Grid zoom (only for Grid mode)")
                    maptype = gr.Dropdown(["roadmap","satellite","terrain","hybrid"], value="roadmap", label="Grid map type")
                    iframe_height = gr.Slider(320, 900, value=520, step=10, label="Map height (px)")
                    places_radius = gr.Slider(500, 4000, value=2000, step=100, label="Places search radius (m)")
                    max_per_cat = gr.Slider(10, 100, value=40, step=5, label="Max markers per category (combined map)")

                with gr.Accordion("Data options", open=False):
                    units_system = gr.Dropdown(["METRIC","IMPERIAL"], value="METRIC", label="Weather units")
                    days = gr.Slider(1, 10, value=5, step=1, label="Forecast days")
                    include_airbnb = gr.Checkbox(value=True, label="Scrape Inside Airbnb nightly prices (GBP)")

                with gr.Row():
                    btn_clear = gr.Button("Reset inputs", variant="secondary")
                    btn_clear.click(
                        _clear_inputs, inputs=None,
                        outputs=[dest, categories, map_mode, iframe_height, include_airbnb, places_radius, max_per_cat, units_system, days]
                    )

            gr.Markdown(
                "<div class='footer-note'>Tip: if no markers appear, increase the radius and make sure Places API is enabled for your key.</div>"
            )

        # ---------- Right results panel ----------
        with gr.Column(scale=2, min_width=520):
            with gr.Tabs():
                with gr.Tab("🗺️ Map"):
                    out_maps = gr.HTML(label="Map")

                with gr.Tab("🌤️ Weather & 🏠 Stays"):
                    with gr.Row():
                        out_weather_airbnb = gr.Markdown(label="Weather & Airbnb (GBP)")
                    out_hist = gr.Plot(label="Airbnb price distribution (GBP)")

                with gr.Tab("🍸 Nightlife Top Picks"):
                    out_nightlife = gr.Markdown(label="Nightlife Quality & Top places")

                with gr.Tab("ℹ️ How it works"):
                    gr.Markdown(
                        """
                        **What you get**
                        - One combined Google Map with markers for your selected categories.
                        - Current conditions & 5–10 day forecast (Google Weather API).
                        - Airbnb nightly price distribution in **GBP** (scraped from InsideAirbnb + FX conversion).
                        - A composite **Nightlife Quality** score plus top places.

                        **Notes**
                        - Price “£” icons are Google’s `price_level` (0–3) → £–££££, not exact GBP.
                        - InsideAirbnb is city-level; we infer currency when needed and convert via frankfurter.app.
                        - Enable: **Maps JavaScript API**, **Places API**, **Weather API** for your key.
                        """
                    )

    # Wiring
    run_btn.click(
        fn=generate_panels,
        inputs=[dest, categories, map_mode, zoom, maptype, iframe_height, units_system, days, include_airbnb, places_radius, max_per_cat],
        outputs=[out_maps, out_weather_airbnb, out_hist, out_nightlife],
    )

if __name__ == "__main__":
    demo.launch()
